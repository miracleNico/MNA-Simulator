# -*- coding: utf-8 -*-
"""MNA_simulation.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1YbJhRmhM_dAc2lXROQXETMfFZ2QNr1Ni
"""

## CELL00
import numpy as np
import re
import collections
import sympy as sp
import time
import matplotlib.pyplot as plt
from numpy.linalg import norm
import math

V_T = "0.025"
I_s = "1e-15"

class CircuitSimulatorError(Exception):
    ##DEFAULT
    def __init__(self, message, code=None):
        super().__init__(message)
        self.code = code
        self.message = message

class NetlistError(CircuitSimulatorError):
    ###Retry get_input
    def __init__(self, message, code="NETLIST_FATAL"):
        super().__init__(message, code)

class SolverConvergenceError(CircuitSimulatorError):
    ### Use Gmin or STEPPING
    def __init__(self, message, code="SOLVER_RETRY"):
        super().__init__(message, code)

def error_handler(message):

    if ":" in message:
            code, msg = message.split(":", 1)
            msg = msg.strip()
    else:
        code = "UNKNOWN"
        msg = message

    if code in ("NETLIST_FATAL", "PARSE_ERROR", "COMPONENT_ERROR"):
        #fatal, fix the netlist.
        raise NetlistError(msg, code=code)

    elif code in ("NR_CONVERGENCE", "JACOBIAN_SINGULAR", "SOLVER_RETRY", "LU_CONVERGENCE"):
        #numerical failures
        raise SolverConvergenceError(msg, code=code)

    else:
        # Default
        raise CircuitSimulatorError(msg, code=code)

## CELL01
class Component:

#set regulation constants
    TYPE = r"(R|C|V|L|I|VCCS|VCVS|CCCS|CCVS|E|F|G|H|D)"
    NUMBER = r"[+-]?(\d+(\.\d*)?|\.\d+)"
    SCIENTIFIC_NOTATION = r"([eE][+-]?\d+)"
    METRIC_SUFFIXES = r"(u|U|m|M|k|K|Meg|MEG|G|%)"

#set correct component paterns with regex
    COMPONENT_PATTERN = re.compile(rf"^({TYPE}\d+)$", re.IGNORECASE)
    INDEPENDENT_VAL_PATTERN = re.compile(f"^{NUMBER}({SCIENTIFIC_NOTATION}|{METRIC_SUFFIXES})?$")
    DEPENDENT_VAL_PATTERN= re.compile(f"^{NUMBER}({SCIENTIFIC_NOTATION}|{METRIC_SUFFIXES})?$")
    NODE_PATTERN = re.compile(r"^(0|n\d+)$", re.IGNORECASE)
    DUTY_CYCLE = re.compile(r"^(\d+(\.\d*)?|\.\d+)(%)?$")


    def get_type(self):
        if self.name.upper().startswith('VCVS'):
            return 'VCVS'
        elif self.name.upper().startswith('VCCS'):
            return 'VCCS'
        elif self.name.upper().startswith('CCVS'):
            return 'CCVS'
        elif self.name.upper().startswith('CCCS'):
            return 'CCCS'
        elif self.name.upper().startswith('R'):
            return 'R'
        elif self.name.upper().startswith('C'):
            return 'C'
        elif self.name.upper().startswith('L'):
            return 'L'
        elif self.name.upper().startswith('V'):
            return 'V'
        elif self.name.upper().startswith('I'):
            return 'I'
        elif self.name.upper().startswith('E'):
            return 'VCVS'
        elif self.name.upper().startswith('G'):
            return 'VCCS'
        elif self.name.upper().startswith('F'):
            return 'CCVS'
        elif self.name.upper().startswith('H'):
            return 'CCCS'
        elif self.name.upper().startswith('D'):
            return 'D'
        elif self.name.upper().startswith('B'):
            return 'B'
        else:
            return None # Unknown type

    def __init__(self, parts):

        if not self.COMPONENT_PATTERN.match(parts[0]):
            error_handler(f"COMPONENT_ERROR: Invalid component name: '{parts[0]}'")
            return
        self.name = parts[0]
        self.node1 = None
        self.node2 = None
        self.value = None
        self.subtype = None
        self.ctrl_node1 = None
        self.ctrl_node2 = None
        self.type = self.get_type()
        self.is_valid = True
        self.is_nonlinear = False
        self.value2 = None
        self.value3 = None ## delay_time or phase-shift

        if self.type in ('R', 'C', 'L'):
            if len(parts) != 4:
                self.is_valid  = False
                error_handler(f"NETLIST_FATAL: '{self.name}' expected 4 parts, got {len(parts)}")
            self.node1 = parts[1]
            self.node2 = parts[2]
            if self.node1 == self.node2:
                self.is_valid  = False
                error_handler(f"COMPONENT_ERROR: '{self.name}' has conflict in nodes: '{self.node1, self.node2}'")
            self.value = parts[3]

        elif self.type in ('V', 'I'):
            if len(parts) >= 4:
                self.subtype = parts[3].upper()

            if self.subtype == "DC":
                if len(parts) != 5:
                      self.is_valid  = False
                      error_handler(f"COMPONENT_ERROR: '{self.name}' expected 5 parts, got {len(parts)}")
                self.node1 = parts[1]
                self.node2 = parts[2]
                if self.node1 == self.node2:
                      self.is_valid  = False
                      error_handler(f"COMPONENT_ERROR: '{self.name}' has conflict in nodes: '{self.node1, self.node2}'")
                self.value = parts[4]

            elif self.subtype in ("SIN", "COS"): # Explicitly check for AC subtypes
                #Assign values first, then validate length and nodes
                if len(parts) != 6:
                      self.is_valid  = False
                      error_handler(f"COMPONENT_ERROR: '{self.name}' expected 6 parts, got {len(parts)}")
                self.node1 = parts[1]
                self.node2 = parts[2]
                self.value = parts[4] # Amplitude for AC
                self.value2 = parts[5] # Freq
                if self.node1 == self.node2:
                      self.is_valid  = False
                      error_handler(f"COMPONENT_ERROR: '{self.name}' has conflict in nodes: '{self.node1, self.node2}'")

            elif self.subtype == "STEP": ## V1 n1 n2 STEP (<amp> <t_step>)|(<amp> <freq> <duty_cycle>)
                if (len(parts) != 6) and (len(parts) != 7):
                      self.is_valid  = False
                      error_handler(f"COMPONENT_ERROR: '{self.name}' expected 6 or 7 parts, got {len(parts)}")
                self.node1 = parts[1]
                self.node2 = parts[2]
                if self.node1 == self.node2:
                      self.is_valid  = False
                      error_handler(f"COMPONENT_ERROR: '{self.name}' has conflict in nodes: '{self.node1, self.node2}'")
                if len(parts) == 6:
                      self.value = parts[4] ## Amp
                      self.value2 = parts[5] ## t_step
                else:
                      self.value = parts[4] ## Amp
                      self.value2 = parts[5] ## Freq
                      self.value3 = parts[6] ## duty_cycle[0,1]

            elif self.subtype == "FUNC": ## V1 n1 n2 FUNC <PERIOD> <EXPRESSION>
                if len(parts) != 6:
                      self.is_valid  = False
                      error_handler(f"COMPONENT_ERROR: '{self.name}' expected 6 parts, got {len(parts)}")
                self.node1 = parts[1]
                self.node2 = parts[2]
                if self.node1 == self.node2:
                      self.is_valid  = False
                      error_handler(f"COMPONENT_ERROR: '{self.name}' has conflict in nodes: '{self.node1, self.node2}'")
                self.value = parts[4] ## periord, if == 0: T = inf
                self.value2 = parts[5] ## store string of expression for arbitrary source

            else:
                self.is_valid = False
                error_handler(f"COMPONENT_ERROR: '{self.name}' has invalid 'V' subtype '{self.subtype}'. Must be 'DC', 'SIN', 'COS', 'STEP' or 'FUNC'.")


        elif self.type in ('VCVS', 'VCCS', 'CCVS', 'CCCS'):
            if len(parts) != 6:
                  self.is_valid  = False
                  error_handler(f"COMPONENT_ERROR: '{self.name}' expected 6 parts, got {len(parts)}")
            self.node1 = parts[1]
            self.node2 = parts[2]
            if self.node1 == self.node2:
                  self.is_valid  = False
                  error_handler(f"COMPONENT_ERROR: '{self.name}' has conflict in nodes: '{self.node1, self.node2}'")
            self.ctrl_node1 = parts[3]
            self.ctrl_node2 = parts[4]
            if self.ctrl_node1 == self.ctrl_node2:
                  self.is_valid  = False
                  error_handler(f"COMPONENT_ERROR: '{self.name}' has conflict in nodes: '{self.name: self.ctrl_node1}'")
            if [self.node1, self.node2] == [self.ctrl_node1, self.ctrl_node2] or [self.node1, self.node2] == [self.ctrl_node2, self.ctrl_node1]:
                  self.is_valid  = False
                  error_handler(f"COMPONENT_ERROR: '{self.name}' has conflict in nodes: '{self.node1, self.node2, self.ctrl_node1, self.ctrl_node2}'")
            self.value = parts[5]

        elif self.type == 'D':
            match len(parts):
              case 3:
                  self.node1 = parts[1]
                  self.node2 = parts[2]
                  self.value = I_s
              case 4:
                  self.node1 = parts[1]
                  self.node2 = parts[2]
                  self.value = parts[3]
              case _:
                  self.is_valid  = False
                  error_handler(f"COMPONENT_ERROR: '{self.name}' expected 3 or 4 parts, got {len(parts)}")
            if self.node1 == self.node2:
                  self.is_valid  = False
                  error_handler(f"COMPONENT_ERROR: '{self.name}' has conflict in nodes: '{self.node1, self.node2}'")


        elif self.type == 'B': ## arbitrary nonlinear component
            if len(parts) != 4:
                  self.is_valid  = False
                  error_handler(f"COMPONENT_ERROR: '{self.name}' expected 4 parts, got {len(parts)}")
            self.node1 = parts[1]
            self.node2 = parts[2]
            self.value = parts[3]
            if self.node1 == self.node2:
                  self.is_valid  = False
                  error_handler(f"COMPONENT_ERROR: '{self.name}' has conflict in nodes: '{self.node1, self.node2}'")


        else:
            error_handler("NETLIST_FATAL: Unknown component or name format")



    def validate(self):

        if not self.is_valid:
            return False

        #validate component name&type
        if self.type is None:
            return error_handler(f"NETLIST_FATAL: '{self.name}' has unknown component type.")

        #validate node names
        nodes_to_check = [self.node1, self.node2]
        if self.ctrl_node1 is not None:
            nodes_to_check.append(self.ctrl_node1)
        if self.ctrl_node2 is not None:
            nodes_to_check.append(self.ctrl_node2)

        for node in nodes_to_check:
            if not self.NODE_PATTERN.match(node):
                return error_handler(f"NETLIST_FATAL: '{self.name}'has invalid node name '{node}'. Must be '0' or 'n#'.")

        # validate ac/dc voltage source
        if self.type in ('V', 'I'):
            # This check is now redundant for 'V' due to explicit subtype handling in __init__,
            # but kept for 'I' if it also gets AC subtypes later.
            if self.subtype not in ('COS','SIN', 'DC','FUNC','STEP'):
                return error_handler(f"'NETLIST_FATAL: {self.name}'has invalid subtype '{self.subtype}'. Must be 'DC', 'SIN', or 'COS'.")
            if self.subtype == 'DC' and not self.INDEPENDENT_VAL_PATTERN.match(self.value):
                return error_handler(f"'NETLIST_FATAL: {self.name}' has invalid value format for DC source Amp '{self.value}'.")
            if (self.subtype in ('SIN', 'COS', 'STEP')) and (not self.DEPENDENT_VAL_PATTERN.match(self.value)) and (not self.DEPENDENT_VAL_PATTERN.match(self.value2)):
                return error_handler(f"NETLIST_FATAL: '{self.name}'has invalid value format for AC source param '{self.value, self.value2}'.")
            if self.subtype == 'STEP' and (not self.DUTY_CYCLE.match(self.value3)):
                return error_handler(f"NETLIST_FATAL: '{self.name}' has invalid value format for STEP source t_step/duty_cycle '{self.value3}'.")
            return True # Passed validation

        #validate independent components
        if self.type in ('R', 'C', 'L', 'D'):
            if not self.INDEPENDENT_VAL_PATTERN.match(self.value):
                return error_handler(f"NETLIST_FATAL: '{self.name}' has invalid value format '{self.value}'.")
            return True # Passed validation

        #dependent sources
        if self.type in ('VCVS', 'VCCS', 'CCVS', 'CCCS'):
            if not self.DEPENDENT_VAL_PATTERN.match(self.value):
                return error_handler(f"NETLIST_FATAL: '{self.name}' has invalid gain value '{self.value}'. Must be [a|aeb|(a(Meg|n|u|m|k))].")
            return True

        return error_handler(f"NETLIST_FATAL: '{self.name}'. Could not validate component.")

## CELL02
class Netlist:
    def __init__(self):
        self.netlist = []
        self.VS_node_sets = []    #uses forzenset to store unordered collection
        self.CS_nodes_all = []
        self.other_nodes_all = []
        self.is_valid = True

    def add_component(self, component):

        if not component.validate():
            self.is_valid = False
            error_handler(f"NETLIST_FATAL: Component {component.name} failed validation.")
            return False

        self.netlist.append(component)

        if component.type in ('V', 'CCVS', 'VCVS'):
            self.VS_node_sets.append(frozenset([component.node1, component.node2]))
            if component.ctrl_node1:
                self.other_nodes_all.extend([component.ctrl_node1, component.ctrl_node2])

        elif component.type in ('I', 'VCCS', 'CCCS'):
            self.CS_nodes_all.extend([component.node1, component.node2])
            if component.ctrl_node1:
                self.other_nodes_all.extend([component.ctrl_node1, component.ctrl_node2])

        else: # R, C,L, D
            self.other_nodes_all.extend([component.node1, component.node2])

        return True

    def get_components(self):
        return self.netlist

## core function, validate netlist and it's component
    def validate(self):
        if not self.is_valid:
            error_handler("NETLIST_FATAL: Netlist contains one or more invalid components.")
            return False

        #is there any duplicated VS node set
        if self.VS_node_sets:
            if len(self.VS_node_sets) > len(set(self.VS_node_sets)):
                error_handler("NETLIST_FATAL: Voltage source parallel conflict: Two or more voltage sources are in parallel.")
                return False

        #if there's any CS-CS jucntion that's connected to anyother component
        if self.CS_nodes_all:
            cs_node_counts = collections.Counter(self.CS_nodes_all) # ['n1', 'n2', 'n2', 'n3']->Counter{'n2':2, 'n1':1, 'n3':1}
            junction_nodes = {node for node, count in cs_node_counts.items() if count > 1}
            if not junction_nodes:
                return True
        ## here only junction nodes without other components connect make CS series conflict
            other_nodes_set = set(self.other_nodes_all)
            not_conflict_nodes = junction_nodes.intersection(other_nodes_set)
            conflict_nodes = junction_nodes - not_conflict_nodes

            if  conflict_nodes:
                error_handler(f"NETLIST_FATAL: Current source series conflict: Node(s) {conflict_nodes} are the only junctions for series current sources.")
                return False

        print("--- Netlist Validation Passed ---")
        return True

##CEll03 the Nonlinear expression parser and N-R solver

def lu_decomposition(A):
## to do: add pivoting, or it may not converge in some cases
    n = A.shape[0]
    L = np.zeros((n, n))
    U = np.zeros((n, n))

    for k in range(n):
        L[k, k] = 1

        for j in range(k, n):
            sum_lu = np.dot(L[k, :k], U[:k, j])
            U[k, j] = A[k, j] - sum_lu

        if np.abs(U[k, k]) < 1e-18:
            return None, None

        for i in range(k + 1, n):
            sum_lu = np.dot(L[i, :k], U[:k, k])
            L[i, k] = (A[i, k] - sum_lu) / U[k, k]

    return L, U

def ill_conditioned(L):
    """
    Check if the lower triangular matrix L is ill-conditioned.
    """
    return False## to be implemented

def forward_substitution(L, b):
    ##L*y = b for y

    n = L.shape[0]
    y = np.zeros((n, 1))

    for i in range(n):
        sum_ly = np.dot(L[i, :i], y[:i])
        y[i] = b[i] - sum_ly
        # No division needed since L[i, i] is 1 (Doolittle)

    return y

def backward_substitution(U, y):

    ##U*x = y for x

    n = U.shape[0]
    x = np.zeros((n, 1))

    for i in range(n - 1, -1, -1):
        sum_ux = np.dot(U[i, i+1:], x[i+1:])
        x[i] = (y[i] - sum_ux) / U[i, i]

    return x


def compile_nl_functions(f_str_vector, size):
    ##use sympy to convert the string vector f into pyton
    ##lambda function for the value f(x) and its Jacobian J_f(x).
    ##returns are like: lambda x_0, x_1, x_2...: {expr}

    x_sym = sp.MatrixSymbol('X_VEC', size, 1)

    f_sym_list = []

    eval_namespace = {'np': sp, 'x': x_sym}

    for expr_str in f_str_vector.flatten():
        try:
            safe_expr_str = expr_str.replace("np.exp", "sp.exp")
            sympify_str = expr_str.replace('x[', 'X_VEC[')
            sympify_str = sympify_str.replace('np.', 'sp.')
            f_sym_list.append(sp.sympify(sympify_str, locals={'X_VEC': x_sym, 'sp': sp}))

        except Exception as e:
            error_handler(f"PARSE_ERROR: Error parsing symbolic expression {expr_str}")
            raise e

    f_sym = sp.Matrix(f_sym_list)
    x_vars = sp.symbols(f'x_0:{size}')
    f_sym_list_simple = []

    for expr_str in f_str_vector.flatten():
        #Replace x[i] to x_i
        for i in range(size):
            expr_str = expr_str.replace(f'x[{i}]', f'x_{i}')
        expr_str = expr_str.replace('np.', 'sp.')
        f_sym_list_simple.append(sp.sympify(expr_str, locals={'sp': sp}))

    f_sym_simple = sp.Matrix(f_sym_list_simple)
    Jf_sym = f_sym_simple.jacobian(x_vars)

    f_func = sp.lambdify(x_vars, f_sym_simple, 'numpy')
    Jf_func = sp.lambdify(x_vars, Jf_sym, 'numpy')

    return f_func, Jf_func ## returns lambda funcs

def is_nonlinear(f_str_vector):
  for expr in f_str_vector.flatten():
      if expr != "0":
          return True
  return False

def solve_dc_nr(G, f_str_vector, b, max_iter=10000, v_tol=1e-9, f_tol=1e-9, init_cond = "DEFAULT"):

##LU or NR solver

    size = G.shape[0]

    if not is_nonlinear(f_str_vector):
        print("--- Detected linear system ---")
        L, U = lu_decomposition(G)

        if L is None: #if close to singular
            print("NR_CONVERGENCE: Linear system is singular (G matrix). Trying Gmin.")
            return None

        y = forward_substitution(L, b)
        x = backward_substitution(U, y)
        return x

    print("--- Detected nonlinear system: compiling functions ---")
    try:
        f_func, Jf_func = compile_nl_functions(f_str_vector, size)
    except Exception as e:
        print(f"PARSE_ERROR: Failed to compile non-linear functions: {e}")
        return None

    print("--- Starting Newton-Raphson Solver ---")

    ##initial GUESS here , to be modified
    norm_F_now = np.inf
    if init_cond == "DEFAULT":
        x = np.zeros((size, 1))
    elif init_cond == "RANDOM":
        x = np.random.rand(size, 1)
        x = np.add(x, -0.5)
        x = np.multiply(x, 2*max(b))
    else:
        x = init_cond

    for i in range(max_iter):
        delta_x_attenuation = 0.5
        x_flat = x.flatten()
        f_k = f_func(*x_flat).reshape(size, 1) ## *x_flat changes an x_flat array to seperate elements
        F_k = (G @ x) + f_k - b

        norm_F_prev = norm_F_now
        norm_F_now = np.linalg.norm(F_k)
        if norm_F_now < f_tol:
            print(f"Converged in {i} iterations (F_norm = {norm_F_now:.2e})")
            return x

        Jf_k = Jf_func(*x_flat)
        J_k = G + Jf_k

        try:
            #L, U = lu_decomposition(J_k)
            #y = forward_substitution(L, -F_k)
            #delta_x = backward_substitution(U, y)
            delta_x =np.linalg.solve(J_k, -F_k)
        except np.linalg.LinAlgError as e:
            error_handler(f"JACOBIAN_SINGULAR: Jacobian is singular at iteration {i}. Solver failed.")
            return None

        x = x + delta_x

        norm_dx = np.linalg.norm(delta_x)
        if norm_dx < v_tol:
            print(f"Converged in {i+1} iterations (dx_norm = {norm_dx:.2e})")
            return x

        if norm_F_now > norm_F_prev: ##delta_x attenuation
            for j in range(20):
                if norm_F_now > norm_F_prev:
                    x = x - delta_x + delta_x * delta_x_attenuation
                    delta_x_attenuation *= 0.5
                    f_k = f_func(*x_flat).reshape(size, 1)
                    F_k = (G @ x) + f_k - b
                    norm_F_now = np.linalg.norm(F_k)
                else: break
                if j == 20:
                    print(f"RuntimeWarning: Solver did not improve after 20 attenuations.")

    error_handler(f"NR_CONVERGENCE: Solver did not converge after {max_iter} iterations.")

##tests
#A = np.array([[ 4.e-14, -4.e-14 , 1.e+00],[-4.e-14,  2.e-02 , 0.e+00],[ 1.e+00 , 0.e+00,  0.e+00]])
#print(lu_decomposition(A))

##CELL04 MNA gen


##converts string number values into fp
def parse_value(value_str):

    match = re.match(r"([+-]?(\d+(\.\d*)?|\.\d+)([eE][+-]?\d+)?)_?([a-zA-Z]*)", value_str, re.IGNORECASE)

    if not match:
        raise error_handler(f"PARSE_ERROR: Could not parse value: {value_str}")

    #extract the numbers and suffixs
    number_part = match.group(1)
    suffix = match.group(5).upper()
    value = float(number_part)

    if suffix == 'G':
        value *= 1e9
    elif suffix == 'MEG':
        value *= 1e6
    elif suffix == 'K':
        value *= 1e3
    elif suffix == 'M':
        value *= 1e-3
    elif suffix == 'U':
        value *= 1e-6
    elif suffix == 'N':
        value *= 1e-9
    elif suffix == 'P':
        value *= 1e-12
    elif suffix == 'F':
        value *= 1e-15
    elif suffix == '%':
        value *= 0.01

    return value


def MNA_generation(netlist_obj, gmin = 0.0):

    node_names = set()
    extra_current_components = []

    ##pass1: find dimension and map matrix index to comp names
    for comp in netlist_obj.get_components():
        ##add nodes
        if comp.node1 is not None:
            node_names.add(comp.node1)
        if comp.node2 is not None:
            node_names.add(comp.node2)

        ##ctrl nodes
        if hasattr(comp, 'ctrl_node1') and comp.ctrl_node1 is not None:
            node_names.add(comp.ctrl_node1)
        if hasattr(comp, 'ctrl_node2') and comp.ctrl_node2 is not None:
            node_names.add(comp.ctrl_node2)

        #find components that introduces new dim
        if comp.type in ('V', 'VCVS', 'CCVS', 'L'):
            extra_current_components.append(comp)

    #remove ground
    node_names.discard('0')

    #map node index to node names
    sorted_nodes = sorted(list(node_names))
    node_map = {name: i for i, name in enumerate(sorted_nodes)}
    num_nodes = len(sorted_nodes)
    current_map = {
        comp.name: i + num_nodes for i, comp in enumerate(extra_current_components)
    }
    num_extra_currents = len(extra_current_components)

    ##init

    size = num_nodes + num_extra_currents
    G = np.zeros((size, size))
    C = np.zeros((size, size))
    f_str = np.full((size, 1), "0", dtype=object)
    b_dc = np.zeros((size, 1))
    b_ac_str = np.full((size, 1), "0", dtype=object)

    ##find node name from index
    def get_index(node_name):
        if node_name == '0':
            return -1  #Use -1 to represent the ground node
        return node_map.get(node_name)

    def stamp(matrix, node_j, node_k, value):
        if node_j != -1:
            matrix[node_j, node_j] += value
        if node_k != -1:
            matrix[node_k, node_k] += value
        if node_j != -1 and node_k != -1:
            matrix[node_j, node_k] -= value
            matrix[node_k, node_j] -= value

    def stamp_symbolic_b(b_vector, index, expression, is_positive=True):
        if index == -1:
            return

        sign = "+" if is_positive else "-"

        if b_vector[index, 0] == "0":
            if is_positive:
                b_vector[index, 0] = expression
            else:
                b_vector[index, 0] = f"-({expression})"
        else:
            b_vector[index, 0] += f" {sign} ({expression})"

    ##pass 2:stamp all components

    for comp in netlist_obj.get_components():

        comp_type = comp.type

        j = get_index(comp.node1)
        k = get_index(comp.node2)

        if comp_type == 'R':
            g = 1.0 / parse_value(comp.value)
            stamp(G, j, k, g)

        elif comp_type == 'C':
            c = parse_value(comp.value)
            stamp(C, j, k, c)
            if gmin > 0.0:
                stamp(G, j, k, gmin)

        elif comp_type == 'L':
            k_l = current_map[comp.name]
            l_val = parse_value(comp.value)

            #il from j to k
            if j != -1:
                G[j, k_l] += 1
            if k != -1:
                G[k, k_l] -= 1

            #vj- vk = Ldi/dt
            # G: vj -vk
            if j != -1:
                G[k_l, j] += 1
            if k != -1:
                G[k_l, k] -= 1
            C[k_l, k_l] += l_val

        elif comp_type == 'I':
            if comp.subtype == 'DC':
                i = parse_value(comp.value)
                if j != -1: b_dc[j] += i #current enters j
                if k != -1: b_dc[k] -= i #current leaves k

            elif comp.subtype == 'SIN':
                amp = parse_value(comp.value)
                freq = parse_value(comp.value2)
                i_expr = f"({amp} * np.sin(2 * np.pi * {freq} * t))"
                stamp_symbolic_b(b_ac_str, j, i_expr, is_positive=True)
                stamp_symbolic_b(b_ac_str, k, i_expr, is_positive=False)

            elif comp.subtype == 'COS':
                amp = parse_value(comp.value)
                freq = parse_value(comp.value2)
                i_expr = f"({amp} * np.cos(2 * np.pi * {freq} * t))"
                stamp_symbolic_b(b_ac_str, j, i_expr, is_positive=True)
                stamp_symbolic_b(b_ac_str, k, i_expr, is_positive=False)

            elif comp.subtype == 'STEP':
                amp = parse_value(comp.value)

                if comp.value3 == None:
                    # single step
                    t_step = parse_value(comp.value2)
                    v_expr = f"({amp} * np.heaviside(t - {t_step}, 1))"
                else:
                    freq = parse_value(comp.value2)
                    period = 1.0 / freq
                    duty_cycle = np.min([parse_value(comp.value3),1.0])
                    t_step = (1.0-duty_cycle) * period
                    pulse_width = duty_cycle * period
                    step_tmodT = f"np.heaviside(np.mod(t, {period}) - {t_step}, 1)"
                    i_expr = f"({amp} * {step_tmodT})"
                stamp_symbolic_b(b_ac_str, j, i_expr, is_positive=True)
                stamp_symbolic_b(b_ac_str, k, i_expr, is_positive=False)

            elif comp.subtype == 'FUNC':
                period = parse_value(comp.value)
                expr_str = comp.value2 # This is the raw string expression

                if period == 0:
                    # inf period, use the expression directly
                    i_expr = f"({expr_str})"
                else:
                    ## periodic, t -> np.mod(t, period)'
                    i_expr = f"({expr_str.replace('t', f'np.mod(t, {period})')})"
                stamp_symbolic_b(b_ac_str, j, i_expr, is_positive=True)
                stamp_symbolic_b(b_ac_str, k, i_expr, is_positive=False)
                ## end arbitrary curren source

        elif comp_type == 'V':
            kv = current_map[comp.name]
            if j != -1: G[j, kv] += 1
            if k != -1: G[k, kv] -= 1
            if j != -1: G[kv, j] += 1
            if k != -1: G[kv, k] -= 1

            if comp.subtype == 'DC':
                v = parse_value(comp.value)
                b_dc[kv] += v

            elif comp.subtype == 'SIN':
                amp = parse_value(comp.value) #comp.value for amplitude
                freq = parse_value(comp.value2)#comp.value2 for freq
                v_expr = f"({amp} * np.sin(2 * np.pi * {freq} * t))"
                stamp_symbolic_b(b_ac_str, kv, v_expr, is_positive=True) # only stamp for AC sources

            elif comp.subtype == 'COS':
                amp = parse_value(comp.value)
                freq = parse_value(comp.value2)
                v_expr = f"({amp} * np.cos(2 * np.pi * {freq} * t))"
                stamp_symbolic_b(b_ac_str, kv, v_expr, is_positive=True)

            elif comp.subtype == 'STEP':
                amp = parse_value(comp.value)

                if comp.value3 == None:
                    # single step
                    t_step = parse_value(comp.value2)
                    v_expr = f"({amp} * np.heaviside(t - {t_step}, 1))"
                else:
                    freq = parse_value(comp.value2)
                    period = 1.0 / freq
                    duty_cycle = np.min([parse_value(comp.value3),1.0])
                    t_step = (1.0-duty_cycle) * period
                    pulse_width = duty_cycle * period
                    step_tmodT = f"np.heaviside(np.mod(t, {period}) - {t_step}, 1)"
                    v_expr = f"({amp} * {step_tmodT})"
                stamp_symbolic_b(b_ac_str, kv, v_expr, is_positive=True)

            elif comp.subtype == 'FUNC':
                period = parse_value(comp.value)
                expr_str = comp.value2

                if period == 0:
                    #not periodic
                    v_expr = f"({expr_str})"
                else:
                    #periodic
                    v_expr = f"({expr_str.replace('t', f'np.mod(t, {period})')})"
                stamp_symbolic_b(b_ac_str, kv, v_expr, is_positive=True)

        elif comp_type == 'VCVS':
            ke = current_map[comp.name]
            gain = parse_value(comp.value)
            c1 = get_index(comp.ctrl_node1)
            c2 = get_index(comp.ctrl_node2)

            #assume i_e flows from j to k
            if j != -1:
                G[j, ke] += 1
            if k != -1:
                G[k, ke] -= 1

            #vj - vk - A*v_ctrl1 + Av_ctrl2 = 0
            if j != -1:
                G[ke, j] += 1
            if k != -1:
                G[ke, k] -= 1
            if c1 != -1:
                G[ke, c1] -= gain
            if c2 != -1:
                G[ke, c2] += gain

        elif comp_type == 'D':

            ## stamp the nonlinear source using symbolic string
            ## eg."1e-14*(np.exp(x[j] - x[k])/ V_T)-1)"

            is_val = parse_value(comp.value)

            # v_j is the voltage at index j, which is f[j]
            v_j_str = f"x[{j}]" if j != -1 else "0"
            v_k_str = f"x[{k}]" if k != -1 else "0"

            v_d_str = f"({v_j_str} - {v_k_str})"
            i_d_expr = f"({is_val} * (np.exp({v_d_str} / {V_T}) - 1))"

            if j != -1:
                if f_str[j, 0] == "0":
                    f_str[j, 0] = i_d_expr
                else:
                    f_str[j, 0] += f" + {i_d_expr}"

            if k != -1:
                if f_str[k, 0] == "0":
                    f_str[k, 0] = f"-({i_d_expr})"
                else:
                    f_str[k, 0] += f" - ({i_d_expr})"
            if gmin > 0.0:
                stamp(G, j, k, gmin)

    return G, C, f_str, b_dc, b_ac_str, num_nodes

## CELL04_HB Harmonic Balance Solver
"""
Gamma for time domian <--> Harmonic vect, for one node point x_i
to prevent fold back (freq domain aliasing due to K point circular convolution),
K=S=2H+1 is close to the Nyquist freq, choose to have more samples in K (time samples).
Use pseudo inverse for inversion of a tall matrix
"""
def create_fourier_matrices(n_harmonics, time_points):
    """
    Returns DFT (Gamma) and Inv_DFT (Gamma_inv) matrices for Real-valued signals.
    basis vector: [DC, cos(w), sin(w), cos(2w), sin(2w)...]
    Implemented LS_PseudoInverse method for non-square Gamma.
    """
    S = 2 * n_harmonics + 1
    K = len(time_points)

    Gamma = np.zeros((S, K))
    Gamma_inv = np.zeros((K, S))

    ## assume time_points are uniformly spaced over one period T

    for k in range(K):
        t_idx = k
        # arg =2pi* k/K

        # Inv_DFT:
        ##x(t) = a0+sum(an*cos + bn*sin)
        Gamma_inv[k, 0] = 1.0 #DC
        for h in range(1, n_harmonics + 1):
            arg = 2 * np.pi * h * k / K
            Gamma_inv[k, 2*h - 1] = np.cos(arg) # a_h
            Gamma_inv[k, 2*h]     = np.sin(arg) # b_h

    # DFT using least squares pseudo inverse
    # a0 = avg(x); an = 2avg(x*cos); bn = 2avg(x*sin)

    Gamma[0, :] = 1.0 / K
    for h in range(1, n_harmonics + 1):
        for k in range(K):
            arg = 2 * np.pi * h * k / K
            Gamma[2*h - 1, k] = (2.0 / K) * np.cos(arg)
            Gamma[2*h, k]     = (2.0 / K) * np.sin(arg)
    return Gamma, Gamma_inv

def reconstruct_time_domain(x_bar, num_vars, H, omega_0, t_array):
    """
    recoonstruct x(t) with direct synthesis
    """
    freq_dim = 2 * H + 1
    results = np.zeros((num_vars, len(t_array)))
    x_reshaped = x_bar.reshape((num_vars, freq_dim))

    for i in range(num_vars):
        coeffs = x_reshaped[i, :]
        val = coeffs[0] # DC
        for h in range(1, H + 1):
            a_h = coeffs[2*h - 1]
            b_h = coeffs[2*h]
            val += a_h * np.cos(h * omega_0 * t_array) + b_h * np.sin(h * omega_0 * t_array)
        results[i, :] = val
    return results

def solve_harmonic_balance(G, C, f_str_vector, b_dc, b_ac_str, omega_0, H, max_iter=100, tol=1e-6):
    """
    Solves the circuit using Harmonic Balance.
    G, C, f_str, b: outputs from MNA_generation
    omega_0: Fundamental angular frequency (rad/s)
    H: Number of harmonics
    """
    num_vars = G.shape[0]       # N
    freq_dim = 2 * H + 1        # S
    total_dim = num_vars * freq_dim # N*S

    ##Expand Linear Matrices using Kronecker Product
    #G_bar = kron(G, I_S).
    Identity_Freq = np.eye(freq_dim)
    G_bar = np.kron(G, Identity_Freq)
    C_bar = np.kron(C, Identity_Freq)

    # use Omega_bar@C_bar instead of get w into C_bar
    # Create the j_omega matrix operator
    # sub matrix for one node: Diag([0, -w, w, -2w, 2w ...]) due to d/dt: (sin->wcos, cos->-wsin)
    # (d/dt)(a*cos(wt) + b*sin(wt)) = -aw*sin(wt) + bw*cos(wt)
    # sub_block at entry 1+2*int is [[0, w], [-w, 0]].

    Omega_block = np.zeros((freq_dim, freq_dim))
    for h in range(1, H + 1):
        w_h = h * omega_0
        idx_cos = 2 * h - 1
        idx_sin = 2 * h
        # d(cos)/dt -> sin coeff: -w
        # d(sin)/dt -> cos coeff: w
        Omega_block[idx_cos, idx_sin] = w_h
        Omega_block[idx_sin, idx_cos] = -w_h

    Omega_bar = np.kron(np.eye(num_vars), Omega_block)

    Y_bar = G_bar + np.matmul(C_bar, Omega_bar)

    K_samples = 2 * H + 1 # Nyquist minimum.
    #if K_samples < 8: K_samples = 16

    period = 2 * np.pi / omega_0
    t_points = np.linspace(0, period, K_samples, endpoint=False)

    Gamma, Gamma_inv = create_fourier_matrices(H, t_points)

    ## b_bar
    b_bar = np.zeros((total_dim, 1))

    # b_bar_dc
    for i in range(num_vars):
        idx_base = i * freq_dim
        b_bar[idx_base] = b_dc[i]

    # b_bar_ac
    try:
        b_ac_func = compile_ac_source_func(b_ac_str)
        b_time_matrix = np.zeros((num_vars, K_samples))
        for k, t_val in enumerate(t_points):
            val_vec = b_ac_func(t_val)
            b_time_matrix[:, k] = val_vec.flatten()

        ##Transform to freqdomain for each node
        for i in range(num_vars):
            time_wave = b_time_matrix[i, :]
            freq_coeffs = np.matmul(Gamma, time_wave) # (S,)
            idx_base = i * freq_dim
            b_bar[idx_base:idx_base+freq_dim, 0] += freq_coeffs

    except Exception as e:
        error_handler(f"HB_ERROR: Failed to compile AC sources: {e}")
        return None

    ##Compile Nonlinear Functions
    if is_nonlinear(f_str_vector):
        f_func, Jf_func = compile_nl_functions(f_str_vector, num_vars)
    else:
        print("--- Linear Circuit Detected in HB ---")
        try:
            x_bar = np.linalg.solve(Y_bar, b_bar)
            return x_bar
        except np.linalg.LinAlgError:
            return None

    ##Newton-Raphson
    x_bar = np.zeros((total_dim, 1)) #Initial Guess

    # TO DO: Init DC guess from DC solution if available
    print(f"--- Starting Harmonic Balance (H={H}, w={omega_0:.2e}) ---")

    for iter_k in range(max_iter):

        x_reshaped = x_bar.reshape((num_vars, freq_dim))

        # x_time: dim(N, K)
        x_time = np.matmul(x_reshaped, Gamma_inv.T)

        #### Nonlinear Evaluation in Time Domain
        i_nl_time = np.zeros((num_vars, K_samples))
        G_nl_time = np.zeros((num_vars, num_vars, K_samples))
        #Stores J at every time point

        for k in range(K_samples):
            v_inst = x_time[:, k] # Voltage vector at time t_k

            #Evaluate current f(v)
            i_inst = f_func(*v_inst)
            i_nl_time[:, k] = i_inst.flatten()

            #Evaluate derivative J(v)
            g_inst = Jf_func(*v_inst)
            G_nl_time[:, :, k] = g_inst

        ##Convert nonlinear currents to frequency domain
        # i_nl_bar: dim(N, S) -> flatten to dim(N*S, 1)
        i_nl_freq = np.matmul(i_nl_time, Gamma.T)
        f_bar = i_nl_freq.reshape((total_dim, 1))

        # Residual or PHI
        # F(V) = Y_bar * x_bar + f_bar - b_bar
        linear_current = np.matmul(Y_bar, x_bar)
        residual = linear_current + f_bar - b_bar

        norm_res = np.linalg.norm(residual)
        if norm_res < tol:
            print(f"HB Converged in {iter_k} iterations. Residual: {norm_res:.2e}")
            return x_bar

        # J_HB = Y_bar + d(f_bar)/d(x_bar)
        # for the df/dx term either use Gamma or
        # For every pair of nodes (i, j), we have a time-varying conductance g_ij(t).
        # G_conversion_ij = Gamma * diag(g_ij(t)) * Gamma_inv

        J_nonlinear = np.zeros((total_dim, total_dim))

        # iterate over the N*N blocks of the MNA matrix
        for r in range(num_vars):     # Row node
            for c in range(num_vars): # Col node

                # conductance waveform g_rc(t)
                g_waveform = G_nl_time[r, c, :] # size (K,)

                weighted_Gamma_inv = g_waveform[:, None] * Gamma_inv # broadcast multiply column-wise

                G_conv_block = np.matmul(Gamma, weighted_Gamma_inv)

                # global Jacobian
                r_idx = r * freq_dim
                c_idx = c * freq_dim

                J_nonlinear[r_idx : r_idx+freq_dim, c_idx : c_idx+freq_dim] = G_conv_block

        J_total = Y_bar + J_nonlinear

        try:
            delta_x = np.linalg.solve(J_total, -residual)
        except np.linalg.LinAlgError:
            print("HB Solver Error: Singular Jacobian")
            return None

        # TO DO: damping logic
        x_bar = x_bar + delta_x

    print("HB Solver did not converge within limit.")
    return None

## CELL05 transient analysis

def compile_ac_source_func(b_ac_str_vector):
    size = b_ac_str_vector.shape[0]
    t = sp.symbols('t')

    b_ac_sym_list = []
    for expr_str in b_ac_str_vector.flatten():
        expr_str = expr_str.replace('heaviside', 'Heaviside')
        expr_str = expr_str.replace('np.m', 'sp.M')
        expr_str = expr_str.replace('np.', 'sp.')
        expr_str = re.sub(r'(sp\.(?:Min|Max))\(\[(.*?)\]\)', r'\1(\2)', expr_str)
        #symbolic expression
        b_ac_sym_list.append(sp.sympify(expr_str, locals={'t': t, 'sp': sp}))

    b_ac_sym = sp.Matrix(b_ac_sym_list)
    b_ac_lambda = sp.lambdify(t, b_ac_sym, 'numpy')

    def b_ac_func(t_val):
        result = b_ac_lambda(t_val)
        return np.array(result).reshape(size, 1)

    return b_ac_func

def solve_transient(G, C, f_str_vector, b_dc, b_ac_str,
                      t_stop, t_step,
                      max_iter=10000, v_tol=1e-9, f_tol=1e-9,init_cond = None):

    print ([v_tol, f_tol])
    size = G.shape[0]

    print("--- Compiling nonlinear f Functions ---")
    is_nl = is_nonlinear(f_str_vector)
    f_func, Jf_func = (None, None)

    if is_nl:
        try:
            f_func, Jf_func = compile_nl_functions(f_str_vector, size)
        except Exception as e:
            error_handler(f"PARSE_ERROR: Failed to compile nonlinear functions: {e}")
            return None, None
    else:
        f_func = lambda *args: np.zeros((size, 1))
        Jf_func = lambda *args: np.zeros((size, size))

    print("--- Compiling AC sources (b_ac) Functions ---")
    try:
        b_ac_func = compile_ac_source_func(b_ac_str)
    except Exception as e:
        error_handler(f"PARSE_ERROR: Failed to compile AC source functions: {e}")
        return None, None

    if init_cond is None:
        print("--- Calculating .op ---")
        b_ac_t0 = b_ac_func(0.0)
        b_t0 = b_dc + b_ac_t0
        x_0 = solve_dc_nr(G, f_str_vector, b_t0) # Solve for t=0
        if x_0 is None:
            error_handler("NR_CONVERGENCE: Could not find DC operating point. Aborting.")
            return None, None
    else:
        print("--- Using provided initial condition ---")
        x_0 = init_cond

    print(f"Found DC operating point:\n{x_0}")

    print("--- Transient Analysis ---")

    t_points = np.arange(0, t_stop + t_step, t_step)
    num_steps = len(t_points)
    results = np.zeros((size, num_steps))
    results[:, 0] = x_0.flatten()

    C_h = C / t_step
    G_be = G + C_h

    start_time = time.time()
    for n in range(num_steps - 1):

        x_n = results[:, n].reshape(-1, 1)
        t_new = t_points[n+1]

        b_ac_now = b_ac_func(t_new)
        b_now = b_dc + b_ac_now

        #backward euler
        b_be = (C_h @ x_n) + b_now

        x_k = x_n.copy()
        converged = False
        for i in range(max_iter):
            #evaluate Fk :converge?
            x_flat = x_k.flatten()
            f_k = f_func(*x_flat).reshape(size, 1)
            F_k = (G_be @ x_k) + f_k - b_be

            norm_F = np.linalg.norm(F_k)
            if norm_F < f_tol:
                converged = True
                break

            #evaluate Jk
            Jf_k = Jf_func(*x_flat)
            J_k = G_be + Jf_k

            #//solve Jk *delta_x = -Fk using LU
            ## print(f"in Jk:{J_k}")
            ##L, U = lu_decomposition(J_k) alternative
            #if L is None:
               # error_handler(f"JACOBIAN_SINGULAR: Jacobian singular at t={t_new:.2e}, iter={i}")
               # converged = False
                #break

            try:
                delta_x = np.linalg.solve(J_k, -F_k)
            except np.linalg.LinAlgError:
                error_handler(f"JACOBIAN_SINGULAR: Jacobian singular at t={t_new:.2e}, iter={i}")
                converged = False
                break

            delta_x = np.linalg.solve(J_k, -F_k)
            x_k = x_k + delta_x

            if np.linalg.norm(delta_x) < v_tol:
                converged = True
                break

        # End Inner!!

        if not converged:
            error_handler(f"NR_CONVERGENCE: NR failed to converge at t={t_new:.2e} s")
            return t_points, results # Return partial results

        #store the converged solution
        results[:, n+1] = x_k.flatten()

    #End of Outer!!!-

    end_time = time.time()
    print(f"Transient analysis complete in {end_time - start_time:.2f} seconds.")
    return t_points, results

##
##main
##
def print_help_message():
    print('-'*40)
    print("MNA Circuit Simulator Help")
    print("="*50)
    print("\nThis simulator parses a circuit netlist to generate MNA analysis.")

    print("\n--- General Format ---")
    print("Each line must define one component in the format:")
    print("<Name> <Node1> <Node2> ... [Value]\n")

    print("--- Component Naming ---")
    print("* Must start with a letter (R, C, L, V, I, E, G, F, H) and end with a number.")
    print("* Examples: R1, V1, E1 (for VCVS), G1 (for VCCS)\n")

    print("--- Node Naming ---")
    print("* Nodes must be '0' (for the ground/reference node) OR 'nx' (e.g., n1, n2, n10).\n")

    print("--- Component Definitions ---")
    print("  Namespace: [component name][number: x] ")
    print("  Rx <Node1> <Node2> <Value>         (e.g., R1 n1 0 1k)")
    print("  Cx <Node1> <Node2> <Value>         (e.g., C1 n2 n1 1.5u)")
    print("  Lx <Node1> <Node2> <Value>         (e.g., L1 n2 0 10m)")
    print("  Ix <Node1> <Node2> DC/SIN/COS/STEP <Value>|(<Amp>,<Freq>,(<Duty_Cycle>))")
    print("  Vx <Node1> <Node2> DC/SIN/COS/STEP <Value>|(<Amp>,<Freq>,(<Duty_Cycle>))")
    print("  Vx|Ix <Node1> <Node2> FUNC <period> 'expression' (e.g., V1 n2 0 FUNC 0 np.exp(-t))")
    print("  Dx <Node1> <Node2> (<Is>) (e.g., D1 n1 n2 1e-14)")

    print("\n  --- Dependent Sources ---")
    print("  Ex (or VCVSx) <N+> <N-> <NC+> <NC-> <Gain>  (e.g., E1 n2 n1 n1 0 100)")
    print("  Gx (or VCCSx) <N+> <N-> <NC+> <NC-> <Gain>  (e.g., G1 n3 0 n1 0 0.5)")
    print("  Fx (or CCCSx) <N+> <N-> <V_control> <Gain> (Not yet supported)")
    print("  Hx (or CCVSx) <N+> <N-> <V_control> <Gain> (Not yet supported)")

    print("\n--- Harmonic Balance ---")
    print("  .hb (<H>)             : Plot spectrum for H harmonics (requires single AC source in netlist)")
    print("  .hb (<H>) <time>       : Plot reconstructed waveform up to <time> with H harmonics")

    print("\n--- Example Netlist (for --entire paste) ---")
    print("""
          V1 n1 0 FUNC np.exp(-t)
          R1 n1 n2 1k
          D1 n2 n3
          C1 n2 n4 1u
          C2 n3 0 1u
          E1 n4 0 n3 0 1
          .end
    """)
    print("="*50 + '\n')

####main loop
def get_and_validate_netlist():


    while True:
        mode_line = input()
        mode = mode_line.strip().lower()
        simulation_mode = "SHOW_MATRIX"
        simulation_param = None
        tran_time = '100m'
        tran_step = '0.01m'

        if mode == '--help':
            print_help_message()
            continue #go back and ask input mode

        try:
            cur_netlist = Netlist()

            print("Enter or Paste Circuit Netlist (type '.end' to finish)")
            print("Format: <Name> <Node1> <Node2> ... [Value]")
            print("Nodes must be '0' or 'nx' (e.g., n1, n2).")
            print("-" * 45)

            line_count = 1
            while True:
                line = input(f"Enter netlist line {line_count}: ")
                if line.strip().lower() == ".op":
                    simulation_mode = "DC_ANALYSIS"
                    continue
                if line.strip().lower().startswith(".tran"):
                    simulation_mode = "TRAN_ANALYSIS"
                    tran_param = line.split()
                    if len(tran_param) == 3 :
                        tran_time = parse_value(tran_param[1])
                        tran_step = parse_value(tran_param[2])
                        simulation_param = [tran_time, tran_step]
                    elif len(tran_param) == 2:
                        tran_time = tran_param[1]
                        simulation_param = [tran_time, '0.01m'] #Default step if not provided
                    else:
                        error_handler("NETLIST_FATAL. Use .tran <time> (<step_time>).")

                if line.strip().lower().startswith(".hb"):
                    simulation_mode = "HB_ANALYSIS"
                    hb_param = line.split()
                    args = hb_param[1:]

                    #default H
                    h_val = 16
                    t_val = None

                    if len(args) == 1:
                        val_str = args[0]
                        if re.match(r"^\d+$", val_str):
                            h_val = int(val_str)
                        else:
                            t_val = parse_value(val_str)

                    elif len(args) >= 2:
                        #.hb <H> <time>
                        h_val = int(parse_value(args[0]))
                        t_val = parse_value(args[1])

                    simulation_param = [h_val, t_val]
                    continue

                if line.strip().lower() == ".end":
                    break
                if line.strip() == "":
                    continue

                parts = line.split()
                comp = Component(parts)
                cur_netlist.add_component(comp)
                line_count += 1

            if not cur_netlist.get_components():
                print("No components entered. Please try again.\n")
                continue #restart loop

            cur_netlist.validate()

            return cur_netlist, simulation_mode, simulation_param

        except NetlistError as error:
            print(f"\n[Validation Error]: {error}")
            print("Clearing all netlist data. Please try again from the beginning.\n")
            continue #restart the get_and_validate

## multi-freq HB analysis
def find_GCD_frequency(freq_list, tolerance=1e-5):
    ###Finds the floats GCD of a list of frequencies.
    if not freq_list:
        return None

    freqs = [f for f in freq_list if f > tolerance]
    if not freqs:
        return None

    gcd_val = freqs[0]

    for f in freqs[1:]:
        while f > tolerance:
            gcd_val, f = f, gcd_val % f

    return gcd_val


if __name__ == "__main__":
    print("MNA simulator v0.52")
    print("Enter --help for HELP.")
    print("Enter ANYTHING for netlist input.")
    print("---------------------------------------------")
    try:
        final_netlist, simulation_mode, simulation_param = get_and_validate_netlist()

        if final_netlist:
            print("\nFinal Validated Components:")
            for comp in final_netlist.get_components():
                print(f"  - {comp.name} (Type: {comp.type}, Value: {comp.value})")

            #GMIN STEPPING
            gmin_steps = [0.0, 1e-12,1e-11,1e-10,1e-9,1e-8,1e-7,1e-6,1e-5,1e-4,1e-3]
            x_solution = None

            for gmin in gmin_steps:
                try:
                    print(f"\n--- Attempting analysis with Gmin = {gmin:.1e} ---")

                    # Regenerate matrices with the current Gmin
                    [G, C, f_str, b_dc, b_ac_str, num_nodes] = MNA_generation(final_netlist, gmin=gmin)

                    # Attempt the simulation
                    match simulation_mode:
                        case "SHOW_MATRIX":
                            print("G Matrix:\n", np.matrix(G))
                            print("C Matrix:\n", np.matrix(C))
                            print("f_str Vector:\n", f_str)
                            print("b_dc Vector:\n", b_dc)
                            print("b_ac_str Vector:\n", b_ac_str)
                            break

                        case "DC_ANALYSIS":
                            if x_solution is not None: ##keep the IC if exist
                                init_guess = x_solution
                            else: init_guess = "DEFAULT"
                            x_solution = solve_dc_nr(G, f_str, b_dc, init_cond=init_guess)
                            print(f"--- Solve successful with Gmin={gmin:.1e} ---")
                            print(f"DC analysis x result: \n{x_solution}'")
                            break

                        case "TRAN_ANALYSIS":
                            if x_solution is None: #find .op iff no dc result
                                print("Finding .op for transient analysis...")
                                b_ac_t0 = compile_ac_source_func(b_ac_str)(0.0)
                                b_t0 = b_dc + b_ac_t0
                                x_solution = solve_dc_nr(G, f_str, b_t0, init_cond="DEFAULT")

                            if x_solution is None:
                                # if .op fails, start the gmin array
                                raise SolverConvergenceError("Could not find .op for current Gmin step.")

                            print(f"--- .op found with Gmin={gmin:.1e}, starting transient ---")
                            [t_points, results] = solve_transient(G, C, f_str, b_dc, b_ac_str, simulation_param[0], simulation_param[1], init_cond = x_solution)

                            if t_points is None:
                                raise SolverConvergenceError("Transient analysis inner loop failed.")

                            print("--- Transient analysis successful ---")

                            plt.figure()
                            # re-create node_map to label plot
                            node_names = set()
                            for comp in final_netlist.get_components():
                                if comp.node1 is not None: node_names.add(comp.node1)
                                if comp.node2 is not None: node_names.add(comp.node2)
                            node_names.discard('0')
                            sorted_nodes = sorted(list(node_names))
                            node_map = {name: i for i, name in enumerate(sorted_nodes)}

                            for i in range(num_nodes):
                                node_name = [name for name, index in node_map.items() if index == i]
                                label = f"V({node_name[0]})"
                                plt.plot(t_points, results[i, :], label=label)

                            plt.xlabel('Time (s)')
                            plt.ylabel('Voltage (V) / Current (A)')
                            plt.legend()
                            plt.title('Transient Analysis Results')
                            plt.grid(True)
                            plt.show()
                            break

                        case "HB_ANALYSIS":
                            source_freqs = []
                            for comp in final_netlist.get_components():
                                if comp.type in ('V', 'I') and comp.subtype in ('SIN', 'COS'):
                                    f_val = parse_value(comp.value2)
                                    if f_val > 0:
                                        source_freqs.append(f_val)

                            source_freqs = sorted(list(set(source_freqs))) #sort existing frequency bases

                            if not source_freqs:
                                print("HB_ERROR: No AC sources found.")
                                break

                            #GCD of base freq
                            if len(source_freqs) == 1:
                                f0 = source_freqs[0]
                            else:
                                f0 = find_GCD_frequency(source_freqs)

                            print(f"--- HB Setup: Detected Base Frequency f0 = {f0:.4e} Hz ---")

                            # H_min >= max_freq/f0
                            max_input_freq = max(source_freqs)
                            min_harmonics_needed = int(np.ceil(max_input_freq / f0))

                            # .hb <H>
                            user_H = int(simulation_param[0]) if simulation_param[0] else 8

                            # If provided H is too small to even see the sources, use Hmin
                            # then incerease Hmin a little bit for better intermodulation products
                            if user_H < min_harmonics_needed:
                                print(f"WARNING: Requested H={user_H} is too low to capture source at {max_input_freq}Hz.")
                                H_harmonics = min_harmonics_needed + 4
                                print(f"-> Auto-adjusting to H={H_harmonics}")
                            else:
                                H_harmonics = user_H

                            t_limit = simulation_param[1]
                            omega_0 = 2 * np.pi * f0

                            x_bar = solve_harmonic_balance(G, C, f_str, b_dc, b_ac_str, omega_0, H_harmonics)

                            if x_bar is None:
                                raise SolverConvergenceError("HB failed to converge.")

                            print("--- HB Analysis Successful ---")

                            #Plotting
                            node_names = set()
                            for comp in final_netlist.get_components():
                                if comp.node1 is not None: node_names.add(comp.node1)
                                if comp.node2 is not None: node_names.add(comp.node2)
                            node_names.discard('0')
                            sorted_nodes = sorted(list(node_names))
                            node_map = {name: i for i, name in enumerate(sorted_nodes)}

                            plt.figure()

                            #Reconstruct waveform: time given
                            if t_limit is not None:
                                t_stop = t_limit
                                ## TO DO: self_adjust resolution
                                t_plot = np.linspace(0, t_stop, 2000)
                                x_t = reconstruct_time_domain(x_bar, len(G), H_harmonics, omega_0, t_plot)

                                for i in range(num_nodes):
                                    node_name = [name for name, index in node_map.items() if index == i]
                                    label = f"V({node_name[0]})"
                                    plt.plot(t_plot, x_t[i, :], label=label)
                                plt.xlabel('Time (s)')
                                plt.title(f'HB Reconstruction (Base f0={f0:.2e}Hz)')

                            #Spectrum
                            else:
                                dim_freq = 2*H_harmonics + 1
                                freqs = np.arange(H_harmonics + 1) * f0

                                for i in range(num_nodes):
                                    node_name = [name for name, index in node_map.items() if index == i]
                                    coeffs = x_bar[i*dim_freq : (i+1)*dim_freq].flatten()
                                    mags = []
                                    mags.append(abs(coeffs[0]))
                                    for h in range(1, H_harmonics+1):
                                        mag = np.sqrt(coeffs[2*h-1]**2 + coeffs[2*h]**2)
                                        mags.append(mag)

                                    #mags = np.array(mags)
                                    #mask = mags > 1e-9

                                    #if np.any(mask):
                                    #   plt.bar(freqs[mask] + i*(f0/20), mags[mask], width=f0/30, label=f"V({node_name[0]})")

                                plt.xlabel('Frequency (Hz)')
                                plt.title(f'Harmonic Spectrum (Base f0={f0:.2e}Hz)')

                            plt.ylabel('Magnitude')
                            plt.legend()
                            plt.grid(True)
                            plt.show()
                            break

                        case _:
                            print(simulation_mode)
                            break

                except SolverConvergenceError as e:
                    print(f"--- SOLVER FAILED (Gmin={gmin:.1e}): {e.message} ---")
                    if gmin == gmin_steps[-1]:
                        print("\n--- GMIN STEPPING FAILED: Analysis aborted. ---")
                    else:
                        print("--- Retrying with larger Gmin... ---")
                        x_solution = None

                except(NetlistError, CircuitSimulatorError) as e: #catch other fatal errors
                    print(f"\n[FATAL ERROR]: {e.message}")

    except NetlistError as e:
        print(f"\n[FATAL NETLIST ERROR]: {e.message}")